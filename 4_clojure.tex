\subsection{History of Clojure}
    Clojure is a dynamic, general-purpose programming language that supports concurrency and functional programming. Every one of Clojure's feature is supported at run-time. Clojure has derived from the language Lisp, where inheriting the "code-as-data" philosophy and the macro system features from Lisp. Clojure is a community-driven development process (open source) and is handled by Clojure community website. Clojure is hosted on the Java Virtual Machine (JVM), sharing the JVM type system and threads. All functions developed are compiled down to JVM bytecode. In addition, Clojure supports dynamic implementation of Java interfaces and classes.
    
\subsubsection{Author(s), Dates}

    Clojure was first introduced to the public on October 16, 2007 by creator Rich Hickey. Hickey wanted a "Lisp-friendly" interface to Java that can be used as a modern Lisp functional programming language and specifically designed for concurrency. Hickey worked on Clojure for nearly two and half years before it's initial release in 2007, without much outside funding. Since then, Clojure has had nine more releases introducing primitive support, improved hashing algorithms, direct linking, and socket server, just to name a few.   
    

\subsubsection{What was available before Clojure?}

    Clojure offers multiple ways to simplify multi-threaded programming, but concurrency is still difficult. However, before Clojure, the popular programming languages were C++ and Java, which haven't evolved much in constructs of concurrent programming (threads, locks) throughout decades. Threads and locks are very basic concurrency features. \cite{galpin_2010}

\subsubsection{Why Clojure?}

    One of the reasons for Clojure's existence are the different ways Clojure looks at handling state and identity. Clojure actually uniquely separates these two ideas where other languages do not. In Clojure, values are immutable and can never change. An example of a value is a number. Maps are a value. A vector with three elements is a value. Whenever in Clojure a user attempts to modify a value (data structure) and change its state, a new value is produced instead. The idea is known as having persistent data structures. Identities in Clojure are named entities which change over time, and get new values. A counter may have a value of 42, but after incrementing it, the value is 43: Same counter, same identity, different value. This is different from other languages where variables serve as identities that typically point to a mutable value which are modified in place
        \cite{website:clojure-lang-reference}
    
    There are other ways that Clojure is unique. Main things that Clojure does differently are the following, there are no primitives, threads, and locks. These are quite common in other languages. Clojure uses four different concurrency models. Each model can symbolize an abstraction above threads and locks. Clojure also includes the ability to use all of Java's libraries along with it's own.
    
    \subsubsection{4 types of Models}
    
    1.) Thread local vars
    
        Vars are the simplest type of concurrency in Clojure, as they are just declarations of variables and their values. 
    
    2.) Synchronous atoms
    
        Atoms are variables whose state can be changed and visible to other threads. Atoms are almost as simple to use as Vars and are fully synchronous. This means that after a function call changes the value of an atom and is returned, it can be assured that all the threads will see the new value.
         
    3.) Transactional refs
    
        Refs provide the most powerful model of concurrency and serves as Clojure's Software Transactional Memory (STM) implementation. The biggest advantage of refs over atoms are coordination. In other words, refs can change the state of multiple objects in a single and atomic transaction.   
        
    4.) Asynchronous agents
    
        Agents give a way to change the state of objects when the programmer doesn't need to wait for it be changed before performing another operation. Agents are also useful when the programmer doesn't care about the ordering of changes made by multiple threads.            
    
    \cite{galpin_2010}

    
\subsection{Design Choices / Features}
    
   Clojure features an array of paradigms and features that help it to be concurrent. Its functional programming paradigm helps set the foundation for many of these practices and includes functions, immutable data structures, and recursive looping. Functions in Clojure do not allow for side effects - they take in values and return new values. Immutable data structures avoid mutating state and provide for \textit{Persistence}, a term used to describe the property where an old version of a collection is still available after a change. Recursive looping is used in the absence of mutable local variables while ensuring that recursive loops use constant space.
    
    Clojure's elegant solution to concurrency is accomplished in several ways. Its overall method of maintaining consistent state, the Software Transactional Memory System (STM), supports information sharing between threads in both  a synchronous and coordinated manner.
    
    As a whole, Clojure deals with concurrency by changing the way programmers think about the state of a program. Clojure considers the values of an identity as nothing more than representing the identity's state, like a snapshot. Since the values are immutable according to Clojure's design, those values can be used and relied upon for reporting or calculation during the course of that identity's state. At another point in time, the identity may acquire a new state with its own values, but this would be considered a new snapshot. Clojure supports this way of thinking by controlling all state changes through Refs and Agents.

\subsubsection{Refs \& Agents}

    Refs and Agents are Clojure's built in tools to support concurrent ``snapshot'' behavior of all identities, and work as such: ``In the case of Refs, any interaction you do must occur within a transaction (else Clojure will throw an exception), all such interaction will see a consistent view of the world as of a point in time, and no changes will proceed unless the states to be changed haven’t been changed by other participants in the meantime. Transactions support synchronous change to multiple Refs. Agents, on the other hand, offer asynchronous change to a single reference. You pass a function and values, and, at some point in the future, that function will be passed the current state of the Agent and the return value of the function will become the Agent’s new state.'' \cite{website:clojure-concurrency}
    
    

\subsubsection{Data Structures}
    
    As alluded to in the previous section, Clojure's data structures are immutable. Some other properties of Clojure's data structures are:
    \begin{itemize}
        \item They are Read-able
        \item They support proper value equality semantics in their implementation of equals
        \item They provide good hash values
    \end{itemize}
    \cite{website:clojure-lang-reference} Despite the benefits of immutable data structures, there are performance setbacks to creating new data structures, mutating them, and then returning them for immutable use afterwards. Mutating an entire array like that is already O(n). Clojure gets around these performance issues by utilizing Transient Data Structures. Transient Data Structures are ``copies'' of the original data structure that share the source without modifying it. Transients support read-only interfaces like \textbf{nth}, \textbf{get}, and \textbf{count}, but require the use of alternate transient functions (\textbf{assoc!}, \textbf{conj!}) instead of \textbf{assoc} and \textbf{conj} to support parallel `changing' operations. These transient functions allow values to be changed but will only return transient values back. When all desired results have been achieved, the programmer can create a persistent data structure from the transient data structure by calling \textbf{persistent!} on the transient data structure. In all cases performing operations with Transient Data Structures are O(1) and this is a significant performance enhancement.
    
    The performance difference can be clearly noted from this code snippet:
	\begin{lstlisting}[language=clojure]
(defn vrange [n]
	(loop [i 0 v []]
		(if (< i n)
			(recur (inc i) (conj v i))
			v)))

(defn vrange2 [n]
	(loop [i 0 v (transient [])]
		(if (< i n)
			(recur (inc i) (conj! v i))
			(persistent! v))))

;;benchmarked(Java 1.8, Clojure 1.7)
(def v (vrange 1000000))  ;; 73.7 ms
(def v2 (vrange2 1000000));; 19.7 ms
	\end{lstlisting}
    
    One key note to make on the use of transients is that they require \textbf{thread isolation}. Each result of a transient operation shares (mutable) structure with the previous, so bad things would happen if more than one thread could alter the transient at once. \cite{website:clojure-lang-reference}
    
\subsection{Our Implementation of Matrix Multiplication}

    We wrote a sample program to perform matrix multiplication by utilizing Clojure's concurrent features to speed up the computation of the matrix results. The key to doing this was to start a new thread for each computation of a dot-product, which is the part of the algorithm in matrix multiplication that takes computing power. Using Clojure's future keyword, we were able to divide up the work among a separate threads to quickly divide up the computing work among the different cores. The results of those findings are here in this table:
    
    \begin{center}
    \begin{tabular}{ | m{5em} | m{5cm}| }  
    \hline
    N & Average Elapsed Time to Run (in seconds) \\ [0.5ex] 
    \hline\hline
    100 & 0.121 \\ 
    \hline
    250 & 1.356 \\
    \hline
    500 & 9.642 \\
    \hline
    750 & 30.710 \\
    \hline
    1000 & 70.513 \\ [1ex] 
    \hline
    \end{tabular}
    \end{center}
    
    The source code for the full program is available in the appendix under the Clojure section.
    
\subsection{Our Reflection on Clojure}

    All in all, the designers of Clojure chose to make a language that combines the best of functional programming with the versatility and portability of the JVM. Because Clojure compiles down to Java bytecode, it makes the language easy to distribute due to the fact that Java is already runs on billions of devices. Clojure sought to provide a language that would allow programmers to solve increasingly frustrating problems with the familiar tools of the JVM with the powerful capabilities of Lisp and functional programming (if sometimes foreign).
    
    The programming language of Clojure provides everything it says it does, but at a significant learning curve cost to the average user. Although Lisp is a largely universal and robust programming language, there are so many things that make it hard to adjust to. Due to the fact that Clojure is functional, combined with the Lisp aspect, the language as a whole is difficult to pick up. While I was seeking to learn Clojure, I was constantly tripped up by the syntax and even the way that Clojure seeks to go about solving problems. To someone who is fluent in imperative programming, it made the language very hard to pick up.
    
    Clojure boasts about supporting concurrency, and it is true, it does this well. The language as a whole includes many concurrency features such as thread-pools and async methods, but the most widespread feature for concurrency is immutability by default, which seeks to decouple state-change and value which most languages cannot keep separate. What is great about Clojure's implementation of this is their core library of data structures is written in java, which makes available to the user safe/fast immutable data structures which are more convenient/effective than other options. Clojure's implementation of immutability on Java is well done.
    
    Since Clojure is a dynamic language, there is always the separate discussion of dynamic vs. static languages. In this case the debate is no different. Clojure as a dynamic language means that it has traded stronger compiler support for increased flexibility, making Clojure useful for being re-purposed or used unpredictably. However like most dynamic languages, it becomes harder to fix problems in the code when the compiler and IDE isn't helping. As a result Clojure has to drive documentation much harder than another language would. 
    
    All that said, once a user is able to pass the learning curve, the programing language lends itself to accomplishing an enormous amount while being robust and powerful. Clojure optimizes for long-term use and long-term simplicity over familiarity and initial ease. Every design choice that was made was driven by ease when not at the expense of primary design concerns.
    
    As an individual user, I learned more about the JVM, what will be a relevant platform for years to come, and was exposed to more Lisp and experience with functional programming. The glimpse into a world that was previously abstracted for me was certainly hard to pick up, but ultimately, I was better off for it.
